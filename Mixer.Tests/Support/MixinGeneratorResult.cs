// Copyright 2023 Subatomix Research Inc.
// SPDX-License-Identifier: ISC

using System.Collections.Immutable;

namespace Mixer;

/// <summary>
///   The result of a compilation and <see cref="MixinGenerator"/> run.
/// </summary>
/// <remarks>
///   Produced by <see cref="RunMixinGenerator(string[])"/> and its overloads.
/// </remarks>
internal readonly ref struct MixinGeneratorResult
{
    /// <summary>
    ///   Initializes a new <see cref="MixinGeneratorResult"/> for a failed
    ///   compilation.
    /// </summary>
    /// <param name="diagnostics">
    ///   The diagnostics reported by the compilation.
    /// </param>
    public MixinGeneratorResult(ImmutableArray<Diagnostic> diagnostics)
    {
        Diagnostics      = Format(diagnostics);
        GeneratedSources = ImmutableDictionary<string, string>.Empty;
        Exception        = null;
    }

    /// <summary>
    ///   Initializes a new <see cref="MixinGeneratorResult"/> for a successful
    ///   compilation followed by a generator run.
    /// </summary>
    /// <param name="result">
    ///   The result of the generator run.
    /// </param>
    public MixinGeneratorResult(GeneratorRunResult result)
    {
        Diagnostics      = Format(result.Diagnostics);
        GeneratedSources = Format(result.GeneratedSources);
        Exception        = result.Exception;
    }

    /// <summary>
    ///   Gets the diagnostics produced by the compilation or generator.
    /// </summary>
    public ImmutableArray<string> Diagnostics { get; }

    /// <summary>
    ///   Gets the sources generated by the generator.
    /// </summary>
    /// <remarks>
    ///   Returns an empty dictionary if the generator did not run or did not
    ///   generate any sources.
    /// </remarks>
    public ImmutableDictionary<string, string> GeneratedSources { get; }

    /// <summary>
    ///   Gets the exception thrown by the generator, if any.
    /// </summary>
    /// <remarks>
    ///   Returns <see langword="null"/> if the generator did not run or did
    ///   not throw an exception.
    /// </remarks>
    public Exception? Exception { get; }

    private static ImmutableArray<string>
        Format(ImmutableArray<Diagnostic> diagnostics)
    {
        return ImmutableArray.CreateRange(diagnostics, d => d.ToString());
    }

    private static ImmutableDictionary<string, string>
        Format(ImmutableArray<GeneratedSourceResult> sources)
    {
        return sources.ToImmutableDictionary(s => s.HintName, s => s.SourceText.ToString());
    }

    public void ShouldBeDiagnostics(params string[] diagnostics)
    {
        Diagnostics     .Should().BeEquivalentTo(diagnostics);
        Exception       .Should().BeNull();
        GeneratedSources.Should().BeEmpty();
    }

    public void ShouldBeGeneratedSources(Sources sources)
    {
        Diagnostics     .Should().BeEmpty();
        Exception       .Should().BeNull();
        GeneratedSources.Should().BeEquivalentTo(sources);
    }
}
